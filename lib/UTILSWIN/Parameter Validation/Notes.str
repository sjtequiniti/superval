Notes on Relevance Rules========================The UI uses **Evaluated Properties** of parameters to determine how to display and validate them. These Evaluated Properties (EPs) are:* Relevant* Required* EnabledThese properties have values in the range `¯1 0 1`. The value of a property may be a constant, or depend upon the values -- even the EPs -- of other parameters.   The Relevance Rules table (there is one for each module) defines the Evaluated Properties of each parameter. The definition is a text string, which might be as simple as `'1'` or an APL expression. The Relevance Rules tables are maintained in Excel, which excludes many APL primitives from the definitions. Some APL primitives are given ASCII wrappers in UTILSWIN#5. Their names, and the names of other tokens defined in the context in which the rules are evaluated, are listed in UTILSWIN#5 in `RESERVED_WORDS`.The Relevance Rules table read at runtime is compiled from the source XLS. The compilation process identifies from the rules references to other parameters, so dependencies can be easily traced at runtime.  ## Initialising a formWhen a form has been drawn and its controls populated with values, `OpenParameters` calls the module function with an `⍵` of `'SetRelevance'`. That in turn calls `Win∆FormValidation 'SetRelevance'`. This calculates the EPs of all the parameters displayed in the form, and calls `Win∆FormValidation 'Change'` for all of them, enabling and hiding controls to match the EPs. ## The cacheA dictionary `⍙CACHE` holds the values of the parameters and also of their EPs. A cache key might be the name of an APL variable, or an expression indexing it. For example, `'STDATE'` or `'RXX[1;]'`. The cache keys for EPs use dot notation, eg `'STDATE.Required'` or `'RXX.Enabled'`. Parameter values are cached because in some contexts the values are drawn from other variables. See Subforms below.    ## On ChangeThe UI reacts to a change in value by calling `Win∆FormValidation 'Change'` for the parameter. Call this a _Change call_. `Win∆FormValidation` updates the cached value of the changed parameter. It then identifies from the Relevance Rules its _clients_ -- parameters whose EPs depend upon its value -- calculates new values for their EPs, and applies them in the UI. A Change call is made for _all_ a form's parameters after initialisation, to ensure all the EPs are applied. But many Change calls may be made as the form is populated. (In the case of the Actives basis editor, over 1000.) In general, EPs cannot be calculated until all the references in the Relevance Rules can be resolved. These references include not only parameter values and EPs but also other values defined as the form is populated, such as `FirstSlice`.   For Change calls made before the form is populated, action is disabled. The criterion is the global `openParameters`. ## SubformsSubforms are used to edit _slices_ (grid columns), defined as a row index into multiple parameters. The values for a slice are assigned to _alternative_ variables. For example, `STDATE` contains values for multiple slices; `stdate` contains the value for the slice currently being edited. The alternative variables are listed in the `Alternatives` column of the Relevance Rules. The rules themselves are defined in terms of the multi-value variables. Call these the _standard_ variables. So, when calculating the EPs for parameters in a subform, a rule that refers to eg `STDATE` must use the value in the variable `stdate`. This is accomplished by caching the values from the alternative variables under the standard names, and resolving all values in the rules from the cache.So when a subform is created, the names of its variables are read from `FormFields at 'variable'`, and their values cached under their standard names. (Keep in mind that _variables_ here can also mean indexed variables, such as `matrix[1;]`.) The UI handles subforms as children of the main form. For example, the UI returns to the main form after editing a Salary slice. The calling functions for the subforms therefore save and restore the prior values of eg the cache and `FormFields`.From the above, the following principle governs the calculation of Evaluated Properties. The rules for calculating EPs are expressed _only_ in terms of standard variables (expressions), never alternatives. While calculating EPs, the values of these are drawn _only_ from the cache, never from `⍎`. These values must therefore be cached _before_ the EPs can be calculated. Thus the recursive `evaluateProperties` function can _never_ cache the value of a variable, only its EPs.## Soft mapping The context-dependent mapping between standard and alternative names is handled by the 'soft mapping' function `mapp`. This maps elements in `⍵` from one list to another, returning unchanged any elements of `⍵` not in the map. For example,          U←'ABCDEFGHIJKLMNOPQRSTUVWXYZ'          L←'abcdefghijklmnopqrstuvwxyz'          L U mapp 'today i am 21, hooray.'    TODAY I AM 21, HOORAY.The characters `'21,.'` do not appear in `L` and are returned unchanged. The `⍺` of `mapp` is formed from `relRules at 'Field' 'Alternative'`, selecting only those entries for which the alternative variable is defined in the workspace. So we can cache eg          (f a)←(⊂2=⎕NC⊃a)sel¨(f a)←relRules at 'Field' 'Alternative'          (a f mapp ∆) push ⍎¨f a mapp ∆←FormFields at 'variable'and know the cache will hold values under standard names regardless of whether `FormFields` lists standard or alternative names. SJT 4/17/2015 10:31:00 AM 